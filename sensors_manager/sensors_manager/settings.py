# -*- coding: utf-8 -*-
"""
Django settings for sensors_manager project.

Generated by 'django-admin startproject' using Django 1.9.3.

For more information on this file, see
https://docs.djangoproject.com/en/1.9/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/1.9/ref/settings/
"""

from collections import OrderedDict
import os

# pylint: disable=import-error
from .constance import CONSTANCE_CONFIG

# import environment-specific configuration
from .settings_env import (
    LOGS_DIR,
    CACHE_DIR,
    S3_OPTION,
    AWS_ACCESS_KEY_ID,
    AWS_SECRET_ACCESS_KEY,
    BUCKET_NAME,
    REGION_NAME,
)

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/1.9/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'g#8gs6^je!136zmzv0=l3daiunuk_cxv8ih41i9gogz1f1a^#y'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django_nose',
    'django_extensions',
    'constance',
    'constance.backends.database',
]

MINES_APPS = [
    'data_collector',
    'data_reader',
]

INSTALLED_APPS += MINES_APPS

CONSTANCE_CONFIG_FIELDSETS = OrderedDict([
    ('S3', tuple(
        var for var in CONSTANCE_CONFIG.keys() if var[:2] == 'S3')),
])


CONSTANCE_BACKEND = 'constance.backends.database.DatabaseBackend'

MIDDLEWARE_CLASSES = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.auth.middleware.SessionAuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'sensors_manager.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'sensors_manager.wsgi.application'


# Database
# https://docs.djangoproject.com/en/1.9/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}


# Password validation
# https://docs.djangoproject.com/en/1.9/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/1.9/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/1.9/howto/static-files/

STATIC_URL = '/static/'


# Test engine
TEST_RUNNER = 'django_nose.NoseTestSuiteRunner'
NOSE_ARGS = ['--exe']


# configuration des logs
LOG_FORMAT = '%(levelname)s|%(asctime)s UTC|%(name)s:%(lineno)s| %(message)s'
LOG_LEVEL = 'DEBUG' if DEBUG else 'INFO'


class LoggingFactory(object):
    """
    Une petite classe pour générer la variable LOGGING.

    Remarque
    --------

    Les logs sont désactivés si LOGS_DIR=None


    Hierarchie des logs
    -------------------

    CRITICAL: erreure critique, à envoyer lorsqu'il y a une anomalie grave de
        notre côté (genre une division par 0)

    ERROR: problème qu'on réussit à rattraper, mais qui ne devrait pas arriver
        quand même. Je mets dans cette catégorie les mauvais usages de l'API
        puisqu'elle n'est utilisée que par d'autres systèmes, donc si une
        mauvaise donnée nous arrive (genre code insee null) c'est que ces
        autres systèmes ont un problème grave

    WARNING: points d'attention

    INFO: pour donner des informations sur ce qui se passe, qui pourrait etre
        utile pour comprendre en temps normal ce qui se passe dans une
        situation

    DEBUG: on se lâche, on peut balancer ce qu'on veut. Utile lorsqu'on est
        en train de développer. Normalement en prod ces données ne devraient
        pas être logguées.


    Principe des logs
    -----------------

    On ne garde que les messages qui sont au moins au niveau LOG_LEVEL.

    Dans le dossier LOGS_DIR, on crée un dossier par log. Dans ces dossiers,
    il y aura un fichier de log par jour.

    On a un dossier pour chacune de nos apps (SGR_ALGO_INSTALLED_APPS).
    On a en plus un dossier "django_db" et "django_request", contenant
    respectivement les logs des requêtes à la base de donnée et des requêtes
    qui arrivent (attention seule les requêtes problématiques sont logguées).

    On a en plus un dossier pour les erreur WARNING, ERROR et CRITICAL.
    """

    def __init__(self):
        self.handlers = {}
        self.loggers = {}

        # on va mettre de côté les messages qui demandent un point d'attention
        self.add_handler('warning', log_level='WARNING')
        self.add_handler('error', log_level='ERROR')
        self.add_handler('critical', log_level='CRITICAL')

    def add_handler(self, name, log_level):
        log_folder = os.path.join(LOGS_DIR, name)
        log_filename = os.path.join(log_folder, name + '.log')
        if not os.path.exists(log_folder):
            os.mkdir(log_folder)
        self.handlers[name] = {
            'level': log_level,
            'formatter': 'app_formatter',
            'filename': log_filename,
            'class': 'data_collector.utils.TimedCompressedRotatingFileHandler',
            'when': 'midnight',
            'interval': 1,
            'utc': True,
        }

    def add_logger(self, app, handler_name):
        self.loggers[app] = {
            'handlers': ['error', 'critical', 'warning', handler_name],
            'level': 'DEBUG',
            'propagate': False,
        }

    def add_app(self, app):
        handler_name = app.replace('.', '_')
        self.add_handler(handler_name, log_level=LOG_LEVEL)
        self.add_logger(app, handler_name)

    def add_apps(self, app_list):
        for app in app_list:
            self.add_app(app)

    def generate_logging(self):
        return {
            'version': 1,
            'disable_existing_loggers': True,
            'handlers': self.handlers,
            'loggers': self.loggers,
            'formatters': {
                'app_formatter': {
                    'format': LOG_FORMAT,
                },
            },
        }


if LOGS_DIR is not None:

    factory = LoggingFactory()
    factory.add_apps(MINES_APPS)
    factory.add_apps(['django.db', 'django.requests'])

    LOGGING = factory.generate_logging()